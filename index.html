<!DOCTYPE html>
<html>
<head>
    <title>Neon Shooter V3.0 - Auto Fire</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* 隱藏滾動條 */
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
            color: #fff;
        }
        canvas {
            background-color: #000;
            display: block;
            border: 1px solid #00FFFF; /* 邊框增加視覺效果 */
            box-shadow: 0 0 20px #00FFFF; /* 霓虹光暈 */
        }
        #scoreDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: #00FFFF;
            text-shadow: 0 0 5px #00FFFF;
            z-index: 10;
        }
        /* V3.0: 移除 FIRE 按鈕的樣式和結構 */
    </style>
</head>
<body>
    <div id="scoreDisplay">Score: 0</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        
        // 確保在不同設備上有合適的尺寸
        canvas.width = Math.min(window.innerWidth * 0.9, 600);
        canvas.height = Math.min(window.innerHeight * 0.9, 800);

        let score = 0;
        let gameRunning = true;
        let touchStart = null; // 用於記錄觸控開始的位置
        let isTouching = false; // 判斷是否正在拖曳

        // --- 玩家設定 ---
        const PLAYER_SIZE = 15;
        const PLAYER_SPEED = 10;
        const playerColor = '#00FF00'; // 玩家顏色 (綠色)
        
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            radius: PLAYER_SIZE
        };

        // --- 子彈設定 (V3.0: 自動射擊) ---
        const BULLET_SIZE = 5;
        const BULLET_SPEED = 8;
        const bulletColor = '#00FFFF'; // 子彈顏色 (青色)
        const bullets = [];

        // 新增：自動射擊的時間控制
        let lastFireTime = 0;
        const FIRE_INTERVAL = 150; // 每 150 毫秒射擊一次 (約每秒 6.6 發)

        function fireBullet(x, y) {
            bullets.push({
                x: x,
                y: y - PLAYER_SIZE, // 從飛機頂部發射
                radius: BULLET_SIZE,
                vx: 0, // 垂直射擊
                vy: -BULLET_SPEED 
            });
        }

        // --- 敵人設定 ---
        const ENEMY_SIZE = 10;
        const ENEMY_SPEED = 3;
        const ENEMY_SPAWN_INTERVAL = 1000; // 每 1000 毫秒生成一個敵人
        let lastSpawnTime = 0;
        const enemies = [];
        const enemyColor = '#FF00FF'; // 敵人顏色 (洋紅色)

        function spawnEnemy() {
            const x = Math.random() * (canvas.width - ENEMY_SIZE * 2) + ENEMY_SIZE;
            const y = -ENEMY_SIZE; // 從螢幕上方外生成
            enemies.push({
                x: x,
                y: y,
                radius: ENEMY_SIZE,
                vy: ENEMY_SPEED,
                health: 1 // 基礎敵人血量
            });
        }

        // --- 繪製函式 ---

        function drawCircle(x, y, radius, color) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            // 霓虹光暈效果
            ctx.shadowColor = color;
            ctx.shadowBlur = 15;
            ctx.closePath();
            ctx.shadowBlur = 0; // 重置陰影，避免影響其他繪製
        }

        function drawPlayer() {
            // 玩家飛機是一個簡單的三角形或圓形
            drawCircle(player.x, player.y, player.radius, playerColor);
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                drawCircle(bullet.x, bullet.y, bullet.radius, bulletColor);
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                drawCircle(enemy.x, enemy.y, enemy.radius, enemyColor);
            });
        }

        // --- 更新函式 ---

        function update() {
            if (!gameRunning) return;

            // 1. 清空畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const currentTime = performance.now();

            // 2. V3.0: 自動射擊邏輯
            if (currentTime - lastFireTime > FIRE_INTERVAL) {
                fireBullet(player.x, player.y);
                lastFireTime = currentTime;
            }

            // 3. 子彈更新
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.y += bullet.vy;

                // 移除超出螢幕的子彈
                if (bullet.y < -bullet.radius) {
                    bullets.splice(i, 1);
                    continue; 
                }

                // 檢查子彈與敵人的碰撞
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bullet.radius + enemy.radius) {
                        // 命中！
                        bullets.splice(i, 1); // 移除子彈 (重要: 必須先移除子彈才能 continue i 的迴圈)
                        enemy.health--;

                        if (enemy.health <= 0) {
                            // 敵人死亡
                            enemies.splice(j, 1);
                            score += 10;
                            scoreDisplay.textContent = `Score: ${score}`;
                        }
                        
                        // 因為子彈已經被移除，所以中斷內層迴圈，進入下一顆子彈的檢查
                        break; 
                    }
                }
            }

            // 4. 敵人更新
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.y += enemy.vy;

                // 移除超出螢幕的敵人 (或直接判斷遊戲結束)
                if (enemy.y > canvas.height + enemy.radius) {
                    enemies.splice(i, 1); 
                }

                // 檢查敵人與玩家的碰撞
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < player.radius + enemy.radius) {
                    // 玩家被擊中，遊戲結束
                    gameRunning = false;
                    alert(`Game Over! Final Score: ${score}`);
                    document.location.reload(); // 重新載入頁面以開始新遊戲
                    return;
                }
            }

            // 5. 敵人生成
            if (currentTime - lastSpawnTime > ENEMY_SPAWN_INTERVAL) {
                spawnEnemy();
                lastSpawnTime = currentTime;
            }

            // 6. 繪製所有物件
            drawPlayer();
            drawBullets();
            drawEnemies();

            requestAnimationFrame(update);
        }

        // --- 觸控 / 滑鼠移動控制 ---

        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            // 處理多點觸控，只取第一個點
            const touch = e.touches ? e.touches[0] : e; 
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        // 開始拖曳
        canvas.addEventListener('mousedown', function(e) {
            touchStart = { x: e.clientX, y: e.clientY };
            isTouching = true;
        });

        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault(); // 防止手機預設行為 (如滾動)
            const pos = getTouchPos(e);
            touchStart = { x: pos.x, y: pos.y };
            isTouching = true;
        });

        // 正在拖曳移動
        canvas.addEventListener('mousemove', function(e) {
            if (!isTouching) return;
            movePlayer(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchmove', function(e) {
            if (!isTouching) return;
            const pos = getTouchPos(e);
            movePlayer(pos.x, pos.y);
        });
        
        function movePlayer(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;
            
            // 將玩家位置直接設定為觸控點的 X 軸，Y 軸限制在底部區域
            player.x = canvasX;
            // 玩家 Y 軸保持在固定位置，或僅允許在底部區域輕微移動
            // 這裡我們選擇將其限制在一個距離底部 50 像素的位置
            player.y = Math.min(canvas.height - 30, Math.max(canvas.height - 100, canvasY));

            // 邊界限制
            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
        }

        // 結束拖曳
        canvas.addEventListener('mouseup', function() {
            isTouching = false;
        });

        canvas.addEventListener('touchend', function() {
            isTouching = false;
        });

        // 開始遊戲迴圈
        requestAnimationFrame(update);

    </script>
</body>
</html>
